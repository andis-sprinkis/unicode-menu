#!/usr/bin/env sh
set -e

script="$(basename "$0")"
help_info="NAME
    ${script} - Select Unicode characters from a menu interface.

SYNOPSIS
    ${script} [-b] [-m COMMAND] [-n COMMAND]

DESCRIPTION
    Lorem ipsum dolor sit amet, qui minim labore adipisicing minim sint cillum sint consectetur cupidatat.

    -b
        To first select the Unicode character block.

    -m COMMAND
        The character block selection menu command.

        %P is a subsitution string for using the built-in prompt text.

    -n COMMAND
        The character selection menu command.

        %P is a subsitution string for using the built-in prompt text.
"

path_file_unicodeblocks="/usr/share/unicode/Blocks.txt"
path_file_unicodedata="/usr/share/unicode/UnicodeData.txt"

[ -r "$path_file_unicodeblocks" ] || {
  echo "$(basename "$0"): This script requires the Blocks.txt file from the package unicode-character-database"
  exit 1
}

[ -r "$path_file_unicodedata" ] || {
  echo "$(basename "$0"): This script requires the UnicodeData.txt file from the package unicode-character-database"
  exit 1
}

opt_b=
opt_m=
opt_n=
opt_h=
while getopts m:n:bh name; do
  case $name in
    b) opt_b=1
       ;;
    h) echo "$help_info"
       exit
      ;;
    m) opt_m=1
       arg_opt_m="$OPTARG"
       ;;
    n) opt_n=1
       arg_opt_n="$OPTARG"
       ;;
    ?) echo "$help_info"
       exit 2
       ;;
  esac
done

# For determining the unicode blocks inexact bounaries, the binary search implementation is extracted from https://github.com/andis-sprinkis/binary-search-shell

hex_to_dec() { printf '%d' "0x${1}"; }

dec() { hex_to_dec "$1"; }

at() {
  echo "$space" | sed "$(("$1" + "1"))!d" # +1 for 0-indexed idx conversion to line num
}

dec_at() { dec "$(at "$1")"; }

block_bound_begin() {
  # Binary search:
  # - Equality - ge
  # - Repetition boundary - min

  tgt="$(hex_to_dec "$code_tgt_begin")" idx_min="0" idx_max="$len_space"
  while [ "$idx_min" -lt "$idx_max" ]; do
    idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
    [ "$(dec_at "$idx_mid")" -ge "$tgt" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
  done

  idx_res="$idx_min" res="$(dec_at "$idx_min")" idx_min="0" idx_max="$idx_res"
  while [ "$idx_min" -lt "$idx_max" ]; do
    idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
    [ "$(dec_at "$idx_mid")" -eq "$res" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
  done
  echo "$idx_min"
}

block_bound_end() {
  # Binary search:
  # - Equality - le 
  # - Repetition boundary - max
  tgt="$(hex_to_dec "$code_tgt_end")" idx_min="-1" idx_max="$(("$len_space" - "1"))"
  while [ "$idx_min" -lt "$idx_max" ]; do
    idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
    [ "$(dec_at $(("$idx_mid" + "1")))" -gt "$tgt" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
  done
  echo "$idx_min"
}

prompt_menu_block="Choose a character block" prompt_menu_char="Choose a character"
menu_block="$(echo "${arg_opt_m:-fzf --prompt='%P: ' --preview-window=hidden}" | sed "s/%P/${prompt_menu_block}/g")"
menu_char="$(echo "${arg_opt_n:-fzf --prompt='%P: ' --preview-window=hidden}" | sed "s/%P/${prompt_menu_char}/g")"

file_unicodedata="$(cut -d ";" -f "1,2,11" --output-delimiter ";" "$path_file_unicodedata")"
all_codes="$(cut -d ";" -f "1" <<< "$file_unicodedata")"

[ "$opt_b" ] && {
  file_unicodeblocks="$(<"$path_file_unicodeblocks")"
  idx_begin_blocks="$(grep "^0000..007F" --line-number <<< $file_unicodeblocks | cut -d ":" -f 1)"
  idx_end_blocks="$(grep "^100000..10FFFF" --line-number <<< $file_unicodeblocks | cut -d ":" -f 1)"

  unicodeblocks="$(printf "%s" "$file_unicodeblocks" | head -n "$idx_end_blocks" | tail -n"+$idx_begin_blocks")"

  menu_item_block="$(echo "$unicodeblocks" | sed -e 's/^/[ /g' -e 's/; / ] - [ /g' -e 's/$/ ]/g' | eval "$menu_block")"

  range="$(printf "%s" "$menu_item_block" | sed -n "s/^\[ \(.*.\) \] -.*$/\1/p" | sed -n "s/\.\./ /p")"

  read -r "code_tgt_begin" "code_tgt_end" < <(echo "$range")
}


[ "$code_tgt_begin" ] && [ "$code_tgt_end" ] && {
  space="$all_codes" len_space="$(wc -l <<< "$space")"
  idx_begin="$(("$(block_bound_begin)" + "1"))" idx_end="$(("$(block_bound_end)" + "1"))"

  unicodedata="$(echo "$file_unicodedata" | head -n "$idx_end" | tail -n"+$idx_begin")" 
  codes="$(echo "$all_codes" | head -n "$idx_end" | tail -n"+$idx_begin")"
} || {
  unicodedata="$file_unicodedata" codes="$all_codes"
}

names="$(
  cut -d ";" -f "2,3" <<< "$unicodedata" | sed -e 's/;$//g' -e 's/;/ | /g' -e 's/$/ ]/g' -e 's/^/[ /g' -e 's/<\|>//g'
)"

chars="$(
  ifs_old=$IFS; IFS=$'\n'

  for code in $codes; do
    [ "$code" = "0000" ] || [ "$code" = "000A" ] && {
      echo "[ â˜  ] -"
      continue
    }

    printf '[ %b ] -\n' "\\U$code"
  done

  IFS=$ifs_old
)"

menu_item_character="$(
  paste -d" " \
    <(echo "$chars") \
    <(echo "$codes" | sed -e 's/$/ ] -/g' -e 's/^/[ /g') \
    <(echo "$names") \
  | eval "$menu_char"
)"

printf "%s" "$menu_item_character" | sed -n "s/^\[ \(.*.\) \] - \[ .*. \] - \[ .*. \]/\1/p"
