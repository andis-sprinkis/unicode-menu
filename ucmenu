#!/usr/bin/env sh
set -e

script="$(basename "$0")"
help_info="NAME
    ${script} - Use a menu program to output a Unicode character's value, property or an escape sequence.

SYNOPSIS
    ${script} [-b] [-m COMMAND] [-n COMMAND] [-r COMMAND] [-k FILE] [-t FILE]

DESCRIPTION
    For presenting the menu options, this script requires a menu application like dmenu, fzf (default) or rofi.

    The final-selected character output property gets printed to stdout.

    -b
        To first select the Unicode character block to limit the character search to.

    -m COMMAND
        The Unicode block selection menu command.

    -n COMMAND
        The Unicode character selection menu command.

    -r COMMAND
        The output selection menu command.

    -k FILE
        The Unicode Character Database (UCD) Blocks.txt file path.

    -t FILE
        The Unicode Character Database (UCD) UnicodeData.txt file path.

    The script requires a menu program like dmenu, fzf or rofi and the Unicode Character Database (UCD).

    For COMMAND argument in -m, -n, -r the string \"%P\" is the subsitution placeholder for using the built-in prompt text.

    The default menu command for block, character and output selection menus is \"fzf --prompt='%P: ' --preview-window=hidden\".

    For example, to instead use dmenu as the menu program and use the default prompt text suffixed with \": \" for the block & character selection menus and a custom prompt text for the output selection menu:
    $(basename "$0") -m \"dmenu -p '%P: '\" -n \"dmenu -p '%P: '\" -r \"dmenu -p 'Custom output menu prompt: '\"
"

opt_b=
opt_h=
opt_k=
opt_m=
opt_n=
opt_r=
opt_t=
while getopts m:n:r:k:t:bh name; do
  case $name in
    b) opt_b="1"
       ;;
    h) echo "$help_info"
       exit
      ;;
    m) opt_m="1"
       arg_opt_m="$OPTARG"
       ;;
    n) opt_n="1"
       arg_opt_n="$OPTARG"
       ;;
    r) opt_r="1"
       arg_opt_r="$OPTARG"
       ;;
    k) opt_k="1"
       arg_opt_k="$OPTARG"
       ;;
    k) opt_t="1"
       arg_opt_t="$OPTARG"
       ;;
    ?) echo "$help_info"
       exit "2"
       ;;
  esac
done

prompt_block="Character block" 
menu_block="$(echo "${arg_opt_m:-fzf --prompt='%P: ' --preview-window=hidden}" | sed "s/%P/${prompt_block}/g")"

prompt_char="Character"
menu_char="$(echo "${arg_opt_n:-fzf --prompt='%P: ' --preview-window=hidden}" | sed "s/%P/${prompt_char}/g")"

prompt_char="Output value"
menu_fmt="$(echo "${arg_opt_r:-fzf --prompt='%P: ' --preview-window=hidden}" | sed "s/%P/${prompt_char}/g")"

path_file_unicodeblocks="${arg_opt_k:-/usr/share/unicode/Blocks.txt}"
path_file_unicodedata="${arg_opt_t:-/usr/share/unicode/UnicodeData.txt}"

[ -r "$path_file_unicodeblocks" ] && [ -r "$path_file_unicodedata" ] || {
  echo "$(basename "$0"): This script requires the Blocks.txt and UnicodeData.txt files from the Unicode Character Database (UCD)."
  exit 1
}

file_unicodedata="$(cut -d ";" -f "1,2,11" --output-delimiter ";" "$path_file_unicodedata")"
all_codes="$(cut -d ";" -f "1" <<< "$file_unicodedata")"

hex_to_dec() { printf '%d' "0x${1}"; }
dec() { hex_to_dec "$1"; }
at() { echo "$space" | sed "$(("$1" + "1"))!d"; } # +1 for 0-indexed idx conversion to line num
dec_at() { dec "$(at "$1")"; }

[ "$opt_b" ] && {
  file_unicodeblocks="$(<"$path_file_unicodeblocks")"
  idx_begin_blocks="$(grep "^0000..007F" --line-number <<< $file_unicodeblocks | cut -d ":" -f 1)"
  idx_end_blocks="$(grep "^100000..10FFFF" --line-number <<< $file_unicodeblocks | cut -d ":" -f 1)"

  unicodeblocks="0000..10FFFF; All Blocks
$(echo "$file_unicodeblocks" | head -n "$idx_end_blocks" | tail -n"+$idx_begin_blocks")"

  selected_block="$(echo "$unicodeblocks" | sed -e 's/^/[ /g' -e 's/; / ] - [ /g' -e 's/$/ ]/g' | eval "$menu_block")"

  [ ! "$selected_block" ] && exit 1

  read -r "code_tgt_begin" "code_tgt_end" < <(
    echo "$(printf "%s" "$selected_block" | sed -n "s/^\[ \(.*.\) \] -.*$/\1/p" | sed -n "s/\.\./ /p")"
  )

  [ "$code_tgt_begin" = "0000" ] && [ "$code_tgt_end" = "10FFFF" ] && {
    unicodedata="$file_unicodedata" selection_codes="$all_codes"
  } || {
    # For determining the unicode blocks inexact bounaries, the binary search implementation is extracted from https://github.com/andis-sprinkis/binary-search-shell

    space="$all_codes" len_space="$(wc -l <<< "$space")"
    idx_begin="$(("$({
      # Binary search:
      # - Equality - greater-or-equal
      # - Repetition boundary - min. index

      tgt="$(hex_to_dec "$code_tgt_begin")" idx_min="0" idx_max="$len_space"
      while [ "$idx_min" -lt "$idx_max" ]; do
        idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
        [ "$(dec_at "$idx_mid")" -ge "$tgt" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
      done

      idx_res="$idx_min" res="$(dec_at "$idx_min")" idx_min="0" idx_max="$idx_res"
      while [ "$idx_min" -lt "$idx_max" ]; do
        idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
        [ "$(dec_at "$idx_mid")" -eq "$res" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
      done

      echo "$idx_min"
    })" + "1"))"

    idx_end="$(("$(
      # Binary search:
      # - Equality - less-or-equal
      # - Repetition boundary - max. index

      tgt="$(hex_to_dec "$code_tgt_end")" idx_min="-1" idx_max="$(("$len_space" - "1"))"
      while [ "$idx_min" -lt "$idx_max" ]; do
        idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
        [ "$(dec_at $(("$idx_mid" + "1")))" -gt "$tgt" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
      done

      echo "$idx_min"
    )" + "1"))"

    unicodedata="$(echo "$file_unicodedata" | head -n "$idx_end" | tail -n"+$idx_begin")" 
    selection_codes="$(echo "$all_codes" | head -n "$idx_end" | tail -n"+$idx_begin")"
  }
} || {
  unicodedata="$file_unicodedata" selection_codes="$all_codes"
}

selection_names="$(
  cut -d ";" -f "2,3" <<< "$unicodedata" | sed -e 's/;$//g' -e 's/;/ | /g' -e 's/$/ ]/g' -e 's/^/[ /g'
)"

selection_chars="$(
  ifs_old=$IFS; IFS=$'\n'

  for code in $selection_codes; do
    [ "$code" = "0000" ] || [ "$code" = "000A" ] && {
      echo "[ â˜  ] -"
      continue
    }

    printf '[ %b ] -\n' "\\U$code"
  done

  IFS=$ifs_old
)"

selected_char="$(
  paste -d" " \
    <(echo "$selection_chars") \
    <(echo "$selection_codes" | sed -e 's/$/ ] -/g' -e 's/^/[ /g') \
    <(echo "$selection_names") \
  | eval "$menu_char"
)"

[ ! "$selected_char" ] && exit 1

selected_char_char="$(echo -n "$selected_char" | sed -n "s/^\[ \(.*.\) \] - \[ .*. \] - \[ .*. \]/\1/p")"
selected_char_code_point="$(echo -n "$selected_char" | sed -n "s/^\[ .*. \] - \[ \(.*.\) \] - \[ .*. \]/\1/p")"
selected_char_name="$(echo -n "$selected_char" | sed -n "s/^\[ .*. \] - \[ .*. \] - \[ \(.*.\) \]/\1/p")"

code_point_dec="$(hex_to_dec "$selected_char_code_point")"
code_point_hex_no_pad="$(printf "%x" "$code_point_dec")"
code_point_hex_4_pad="$(printf "%04x" "$code_point_dec")"
code_point_hex_6_pad="$(printf "%06x" "$code_point_dec")"
code_point_hex_8_pad="$(printf "%08x" "$code_point_dec")"
char_utf8_hex="$(echo -n "$selected_char_char" | hexdump -e '5/1 "0x%02x "' | sed -e 's/ 0x  //g')"
char_utf16_hex="$(echo -n "$selected_char_char" | iconv -f utf-8 -t utf-16 | hexdump -e '3/2 "0x%04x "' | sed -e 's/0xfeff //g' -e 's/ 0x    //g')"
char_utf32_hex="$(echo -n "$selected_char_char" | iconv -f utf-8 -t utf-32 | hexdump -e '2 "0x%08x"' | sed -e 's/0x0000feff//g')"
char_utf8_urlencode="$(echo -n "$selected_char_char" | hexdump -e '5/1 "%02x"' | sed -e 's/ *//g' -e 's/\(..\)/%\1/g')"

output_char="$selected_char_char"
output_name_std="$selected_char_name"
output_code_point_std="U+${selected_char_code_point}"
output_code_point_dec="${code_point_dec}"
output_code_point_hex="0x${code_point_hex_no_pad}"
output_utf8_hex="${char_utf8_hex}"
output_utf16_hex="${char_utf16_hex}"
output_utf32_hex="${char_utf32_hex}"
output_code_point_escape_html_hex="&#${code_point_hex_no_pad};"
output_code_point_escape_html_dec="&#${code_point_dec};"
output_utf8_urlencode="$char_utf8_urlencode"
output_code_point_escape_css="\\${code_point_hex_no_pad}"
output_code_point_escape_css_6_digit="\\${code_point_hex_6_pad}"
output_url_wikipedia="https://en.wikipedia.org/wiki/$char_utf8_urlencode"

selected_ouput="$(echo "[ ${output_char} ] - [ Character ]
[ ${output_name_std} ] - [ Name | Standard ]
[ ${output_code_point_std} ] - [ Code point | Hex. | Standard ]
[ ${output_code_point_dec} ] - [ Code point | Dec. ]
[ ${output_code_point_hex} ] - [ Code point | Hex. ]
[ ${output_utf8_hex} ] - [ UTF-8 | Hex. ]
[ ${output_utf16_hex} ] - [ UTF-16 | Hex. ]
[ ${output_utf32_hex} ] - [ UTF-32 | Hex. ]
[ ${output_utf8_urlencode} ] - [ UTF-8 | Hex. | Esc. | URL ]
[ ${output_code_point_escape_html_dec} ] - [ Code point | Dec. | Esc. | HTML, XML ]
[ ${output_code_point_escape_html_hex} ] - [ Code point | Hex. | Esc. | HTML, XML ]
[ ${output_code_point_escape_css} ] - [ Code point | Hex. | Esc.| CSS ]
[ ${output_code_point_escape_css_6_digit} ] - [ Code point | Hex. | Esc. | 6 digits | CSS ]
[ ${output_url_wikipedia} ] - [ Wikipedia ]" | eval "$menu_fmt")"

[ ! "$selected_ouput" ] && exit 1

output="$(echo -n "$selected_ouput" | sed -n "s/^\[ \(.*.\) \] - \[ .*. \]/\1/p")"

echo -n "$output"
