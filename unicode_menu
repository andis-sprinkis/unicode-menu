#!/usr/bin/env sh
set -e

script="$(basename "$0")"
help_info="NAME
    ${script} - Select Unicode characters from a menu interface.

SYNOPSIS
    ${script} [-b] [-m COMMAND] [-n COMMAND]

DESCRIPTION
    Lorem ipsum dolor sit amet, qui minim labore adipisicing minim sint cillum sint consectetur cupidatat.

    -b
        To first select the Unicode character block.

    -m COMMAND
        The character block selection menu command.

        %P is a subsitution string for using the built-in prompt text.

    -n COMMAND
        The character selection menu command.

        %P is a subsitution string for using the built-in prompt text.
"

path_file_unicodeblocks="/usr/share/unicode/Blocks.txt"
path_file_unicodedata="/usr/share/unicode/UnicodeData.txt"

[ -r "$path_file_unicodeblocks" ] && [ -r "$path_file_unicodedata" ] || {
  echo "$(basename "$0"): This script requires the Blocks.txt and UnicodeData.txt files from the package unicode-character-database"
  exit 1
}

opt_b=
opt_h=
opt_m=
opt_n=
while getopts m:n:bh name; do
  case $name in
    b) opt_b=1
       ;;
    h) echo "$help_info"
       exit
      ;;
    m) opt_m=1
       arg_opt_m="$OPTARG"
       ;;
    n) opt_n=1
       arg_opt_n="$OPTARG"
       ;;
    ?) echo "$help_info"
       exit 2
       ;;
  esac
done

prompt_block="Choose a character block" 
menu_block="$(echo "${arg_opt_m:-fzf --prompt='%P: ' --preview-window=hidden}" | sed "s/%P/${prompt_block}/g")"

prompt_char="Choose a character"
menu_char="$(echo "${arg_opt_n:-fzf --prompt='%P: ' --preview-window=hidden}" | sed "s/%P/${prompt_char}/g")"

file_unicodedata="$(cut -d ";" -f "1,2,11" --output-delimiter ";" "$path_file_unicodedata")"
all_codes="$(cut -d ";" -f "1" <<< "$file_unicodedata")"

[ "$opt_b" ] && {
  file_unicodeblocks="$(<"$path_file_unicodeblocks")"
  idx_begin_blocks="$(grep "^0000..007F" --line-number <<< $file_unicodeblocks | cut -d ":" -f 1)"
  idx_end_blocks="$(grep "^100000..10FFFF" --line-number <<< $file_unicodeblocks | cut -d ":" -f 1)"

  unicodeblocks="$(printf "%s" "$file_unicodeblocks" | head -n "$idx_end_blocks" | tail -n"+$idx_begin_blocks")"

  selected_block="$(echo "$unicodeblocks" | sed -e 's/^/[ /g' -e 's/; / ] - [ /g' -e 's/$/ ]/g' | eval "$menu_block")"

  read -r "code_tgt_begin" "code_tgt_end" < <(
    echo "$(printf "%s" "$selected_block" | sed -n "s/^\[ \(.*.\) \] -.*$/\1/p" | sed -n "s/\.\./ /p")"
  )
}

# For determining the unicode blocks inexact bounaries, the binary search implementation is extracted from https://github.com/andis-sprinkis/binary-search-shell

hex_to_dec() { printf '%d' "0x${1}"; }
dec() { hex_to_dec "$1"; }
at() { echo "$space" | sed "$(("$1" + "1"))!d"; } # +1 for 0-indexed idx conversion to line num
dec_at() { dec "$(at "$1")"; }

[ "$code_tgt_begin" ] && [ "$code_tgt_end" ] && {
  space="$all_codes" len_space="$(wc -l <<< "$space")"
  idx_begin="$(("$({
    # Binary search:
    # - Equality - ge
    # - Repetition boundary - min

    tgt="$(hex_to_dec "$code_tgt_begin")" idx_min="0" idx_max="$len_space"
    while [ "$idx_min" -lt "$idx_max" ]; do
      idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
      [ "$(dec_at "$idx_mid")" -ge "$tgt" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
    done

    idx_res="$idx_min" res="$(dec_at "$idx_min")" idx_min="0" idx_max="$idx_res"
    while [ "$idx_min" -lt "$idx_max" ]; do
      idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
      [ "$(dec_at "$idx_mid")" -eq "$res" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
    done
    echo "$idx_min"
  })" + "1"))"

  idx_end="$(("$(
    # Binary search:
    # - Equality - le 
    # - Repetition boundary - max
    tgt="$(hex_to_dec "$code_tgt_end")" idx_min="-1" idx_max="$(("$len_space" - "1"))"
    while [ "$idx_min" -lt "$idx_max" ]; do
      idx_mid="$(("$idx_min" + ("$idx_max" - "$idx_min") / "2"))"
      [ "$(dec_at $(("$idx_mid" + "1")))" -gt "$tgt" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
    done
    echo "$idx_min"
  )" + "1"))"

  unicodedata="$(echo "$file_unicodedata" | head -n "$idx_end" | tail -n"+$idx_begin")" 
  selection_codes="$(echo "$all_codes" | head -n "$idx_end" | tail -n"+$idx_begin")"
} || {
  unicodedata="$file_unicodedata" selection_codes="$all_codes"
}

selection_names="$(
  cut -d ";" -f "2,3" <<< "$unicodedata" | sed -e 's/;$//g' -e 's/;/ | /g' -e 's/$/ ]/g' -e 's/^/[ /g' -e 's/<\|>//g'
)"

selection_chars="$(
  ifs_old=$IFS; IFS=$'\n'

  for code in $selection_codes; do
    [ "$code" = "0000" ] || [ "$code" = "000A" ] && {
      echo "[ â˜  ] -"
      continue
    }

    printf '[ %b ] -\n' "\\U$code"
  done

  IFS=$ifs_old
)"

selected_char="$(
  paste -d" " \
    <(echo "$selection_chars") \
    <(echo "$selection_codes" | sed -e 's/$/ ] -/g' -e 's/^/[ /g') \
    <(echo "$selection_names") \
  | eval "$menu_char"
)"

printf "%s" "$selected_char" | sed -n "s/^\[ \(.*.\) \] - \[ .*. \] - \[ .*. \]/\1/p"
