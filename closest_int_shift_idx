#!/usr/bin/env sh
set -e

help_info="NAME
    $(basename "$0") - Find the closest integer to target in the positive or the negative direction.

SYNOPSIS
    $(basename "$0") -t INTEGER -s FILE [-i] [-d DIRECTION] [-r DIRECTION] [-b BASE] [-g]

DESCRIPTION
    In FILE containing a list of integers, searches for the closest integer to the target INTEGER in the positive (p) or the negative (n) direction.

    If exact number exists in given space - prints it as the result.

    If exact number does not exist in given space - prints a positive or negative direction closest entry to the target as the result.

    If no suitable number is found prints the error message and exits with code 1.

    -t INTEGER 
        Target number - an INTEGER.

    -s FILE
        FILE containing the search space.

        File contents - a linebreak delimited, sorted, min-to-max directional list of non-repeating, negative signed integers.

        For example:
        -100
        4
        5
        9
        45

        or

        -E01EF
        0000
        0001
        0007
        00AB
        E01EF
        10FFFD

    -d DIRECTION
        Search direction.

        Positive - p (default)
        Negative - n

        e.g. for search space 1 2 4 5 and the target number 3
        p - the result is 4 number at the index 3
        n - the result is 2 number at the index 2

    -r DIRECTION
        Repeating value selection direction.

        Negative - n (default)
        Positive - p

        e.g. for search space 1 3 3 3 5 and the target number 3
        n - the result is number 3 at the index 2
        p - the result is number 3 at the index 4

    -i
        Prints the result number index before the result value.

        e.g.
        The index is 1 and the number 22 - prints 1:22
        The index is 81 and the number is -FFFF - prints 81:-FFFF
    -b BASE
        The numerical base for the target and seach space.

        Decimal - dec (default)
        Hexadecimal - hex

    -g
        Prints debug information during the search.

    -h
        Prints this message.
"

hex_to_dec() {
  sign_n="$(cut -c1 <<< "$1")"

  [ "$sign_n" = "-" ] && {
    printf '%d' "${sign_n}0x$(echo "$1" | cut -c2-)"
    return
  }

  printf '%d' "0x$1";
}

opt_b=
opt_d=
opt_r=
opt_g=
opt_h=
opt_i=
opt_s=
opt_t=
while getopts b:d:r:s:t:ghi name; do
  case $name in
    b) opd_b=1
       arg_opt_b="$OPTARG"
       ;;
    d) opt_d=1
       arg_opt_d="$OPTARG"
       ;;
    g) opt_g=1
       ;;
    h) echo "$help_info"
       exit
      ;;
    i) opt_i=1
       ;;
    r) opt_r=1
       arg_opt_r="$OPTARG"
       ;;
    s) opt_s=1
       arg_opt_s="$OPTARG"
       ;;
    t) opt_t=1
       arg_opt_t="$OPTARG"
       ;;
    ?) echo "$help_info"
       exit 2
       ;;
  esac
done

# Option -g

debug="$opt_g"

# Option -b

[ "$arg_opt_b" ] && [ ! "$arg_opt_b" = "dec" ] && [ ! "$arg_opt_b" = "hex" ] && {
  echo "$(basename $0): The BASE argument for option -b is not valid. It must be either 'dec' or 'hex'."
  exit 2
}

base="${arg_opt_b:-dec}"

# Option -t

[ ! "$opt_t" ] && {
  echo "$(basename $0): Required option missing - -t NUMBER"
  exit 2
}

tgt_orig="$arg_opt_t"
[ "$base" = "dec" ] && tgt="$tgt_orig"
[ "$base" = "hex" ] && tgt="$(hex_to_dec "$tgt_orig")"

# Option -s

[ ! "$opt_s" ] && {
  echo "$(basename $0): Required option missing - -s FILE"
  exit 2
}

[ ! -e "$arg_opt_s" ] && {
  echo "$(basename $0): The file path given in search space argument FILE for option -s doesn't point to an existing file."
  exit 2
}

space="$(<"$arg_opt_s")"

# Option -d

[ "$arg_opt_d" ] && [ ! "$arg_opt_d" = "p" ] && [ ! "$arg_opt_d" = "n" ] && {
  echo "$(basename $0): The DIRECTION argument for option -d is not valid. It must be either 'p' or 'n'."
  exit 2
}

dir_sch="${arg_opt_d:-"p"}"

# Option -r

[ "$arg_opt_r" ] && [ ! "$arg_opt_r" = "p" ] && [ ! "$arg_opt_r" = "n" ] && {
  echo "$(basename $0): The DIRECTION argument for option -r is not valid. It must be either 'p' or 'n'."
  exit 2
}

dir_rpt="${arg_opt_r:-"n"}"

# Option -i

print_idx="$opt_i"

# Binary search

print_state() {
  [ ! "$debug" ] && return

  min="$(at "$idx_min")"
  max="$(at "$idx_max")"
  len="$(("$idx_max" - "$idx_min"))"

  state="----:
:
Target value:${tgt}
Search dir.:${dir_sch}
Repeat. val. dir.:${dir_rpt}
Search space leng.:${len}
Middle index:${idx_mid}
Middle value:${mid}
Minimum index:${idx_min}
Minimum value:${min}
Maximum index:${idx_max}
Maximum value:${max}
Iteration:${itr}"

  column -t -s ':' -W 2 <<< "$state"
  echo
}

at() {
  echo "$space" | sed "${1}!d"
}

found() {
  print_state

  [ "$print_idx" ] && { echo "${1}:${2}"; exit; }
  echo "$2"; exit
}

not_found() {
  echo "$(basename $0): No search space number in the given direction from the target number."
  exit 1
}

idx_min="1"
idx_max="$(wc -l <<< "$space")"

while [ "$idx_min" -lt "$idx_max" ]; do
  itr="$(("$itr" + "1"))"

  idx_mid="$((("$idx_min" + "$idx_max") / "2"))"

  mid="$(at "$idx_mid")"

  print_state

  { 
    [ "$dir_rpt" = "n" ] && {
      [ "$mid" -lt "$tgt" ] && idx_min="$(("$idx_mid" + "1"))" || idx_max="$idx_mid"
    } 
  } || {
    [ "$dir_rpt" = "p" ] && {
      [ "$mid" -gt "$tgt" ] && idx_max="$idx_mid" || idx_min="$(("$idx_mid" + "1"))"
    }
  }

  print_state
done

[ "$dir_rpt" = "n" ] && found "$idx_min" "$(at "$idx_min")"
[ "$dir_rpt" = "p" ] && found "$(("$idx_max" - "1"))" "$(at "$(("$idx_max" - "1"))")"
